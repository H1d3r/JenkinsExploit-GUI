package fun.fireline.tools;

// http 请求对象，取自 shack2 的Java反序列化漏洞利用工具V1.7

import fun.fireline.core.ExploitInterface;
import fun.fireline.exp.jenkins.*;

import java.io.InputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

public class Tools {
    public Tools() {
    }


    public static String checkTheDomain(String weburl) {
        if ("".equals(weburl.trim())) {
            return "";
        } else {
            if (!weburl.startsWith("http")) {
                weburl = "http://" + weburl;
            }

            if (!weburl.endsWith("/")) {
                weburl = weburl + "/";
            }

            return weburl;
        }
    }

    public static String urlParse(String url) {
        if (!url.contains("http")) {
            url = "http://" + url;
        }

        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }

        return url;
    }


    public static String getDate() {
        Date d = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return sdf.format(d);
    }


    // 根据选择对应的漏洞检测
    public static ExploitInterface getExploit(String vulName) {
        ExploitInterface ei = null;

        // Jenkins相关漏洞
        if(vulName.contains("CVE-2015-8103")){
            ei = new CVE_2015_8103();
        } else if(vulName.contains("CVE-2016-0792")){
            ei = new CVE_2016_0792();
        }else if(vulName.contains("CVE-2017-1000353")){
            ei = new CVE_2017_1000353();
        } else if(vulName.contains("CVE-2018-1000600")){
            ei = new CVE_2018_1000600();
        }else if(vulName.contains("CVE-2018-1000861")) {
            ei = new CVE_2018_1000861();
        } else if(vulName.contains("CVE-2018-1999002")){
            ei = new CVE_2018_1999002();
        }else if(vulName.contains("CVE-2019-1003000")){
            ei = new CVE_2019_1003000();
        }else if(vulName.contains("CVE-2019-1003005")){
            ei = new CVE_2019_1003005();
        }else if(vulName.contains("CVE-2024-23897")) {
            ei = new CVE_2024_23897();
        }

        return (ExploitInterface) ei;
    }


    // 随机字符
    public static String getRandomString(int length) {
        String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new Random();
        StringBuilder sb = new StringBuilder();

        for(int i = 0; i < length; ++i) {
            int number = random.nextInt(62);
            sb.append(str.charAt(number));
        }

        return sb.toString();
    }


    // 获取weblogic 的exp文本
    public static String getExp(String path) {
        InputStream in = Tools.class.getClassLoader().getResourceAsStream(path);

        Scanner s = (new Scanner(in)).useDelimiter("\\A");
        String str = s.hasNext() ? s.next() : "";

        return str;
    }

}
