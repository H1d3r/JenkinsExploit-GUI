package fun.fireline.tools;

// http 请求对象，取自 shack2 的Java反序列化漏洞利用工具V1.7

import fun.fireline.core.ExploitInterface;
import fun.fireline.exp.jenkins.*;
import fun.fireline.exp.tools.dnslogSetting;

import java.io.IOException;
import java.util.HashMap;
import java.util.Random;

public class Tools {
    public Tools() {
    }


    public static String urlParse(String url) {
        if (!url.contains("http")) {
            url = "http://" + url;
        }

        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }

        return url;
    }


    // 根据选择对应的漏洞检测
    public static ExploitInterface getExploit(String vulName) {
        ExploitInterface ei = null;

        // Jenkins相关漏洞
        if(vulName.contains("CVE-2015-8103")){
            ei = new CVE_2015_8103();
        } else if(vulName.contains("CVE-2016-0792")){
            ei = new CVE_2016_0792();
        }else if(vulName.contains("CVE-2017-1000353")){
            ei = new CVE_2017_1000353();
        } else if(vulName.contains("CVE-2018-1000600")){
            ei = new CVE_2018_1000600();
        }else if(vulName.contains("CVE-2018-1000861")) {
            ei = new CVE_2018_1000861();
        } else if(vulName.contains("CVE-2018-1999002")){
            ei = new CVE_2018_1999002();
        }else if(vulName.contains("CVE-2019-1003000")){
            ei = new CVE_2019_1003000();
        }else if(vulName.contains("CVE-2019-1003005")){
            ei = new CVE_2019_1003005();
        }else if(vulName.contains("CVE-2024-23897")) {
            ei = new CVE_2024_23897();
        }

        return (ExploitInterface) ei;
    }

    //判断Jenkins 普通版本和LTS版本
    public static boolean compare1(String version){
        int count = version.split("\\.").length - 1;
        if(count==1){
            return true;
        }else{
            return false;
        }
    }

    //比较版本
    public static int compare2(String version1, String version2) {
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        int length = Math.max(v1.length, v2.length);
        for (int i = 0; i < length; i++) {
            double num1 = (i < v1.length) ? Double.parseDouble(v1[i]) : 0;
            double num2 = (i < v2.length) ? Double.parseDouble(v2[i]) : 0;
            if (num1 < num2) {
                return -1;
            } else if (num1 > num2) {
                return 1;
            }
        }
        return 0;
    }

    //先判断出是普通版本还是LTS版本,然后再进行比较
    public static boolean compareVersion(String version1,String version2,String version3){
        if(compare1(version1)){
            if(compare2(version1,version2)<=0){
                return true;
            }
        }else {
            if(compare2(version1,version3)<=0){
                return true;
            }
        }
        return false;
    }

    //dnslog api验证无回显命令执行
    public static boolean dnslog_verify(dnslogSetting dnslogSetting,String vul){
        //目的是防止请求api过于频繁造成误差
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String domain = dnslogSetting.getDomain();
        String token = dnslogSetting.getToken();
        String type = dnslogSetting.getType();
        String user = domain.split("\\.")[0];
        String verify = "";
        HashMap<String,String> headers = new HashMap<>();
        if(type.equals("dnslog.pw")){
            verify = String.format("http://dnslog.pw/api/dns/%s/%s/?token=%s",user,vul,token);
            Response response = HttpTools.get(verify,headers,"UTF-8");
            if(response.getText().contains("True")){
                return true;
            }else {
                return false;
            }
        }else if(type.equals("ceye.io")){
            verify = String.format("http://api.ceye.io/v1/records?token=%s&type=dns&filter=%s",token,vul);
            Response response = HttpTools.get(verify,headers,"UTF-8");
            if(response.getText().contains("id")){
                return true;
            }else {
                return false;
            }
        }
        return false;
    }

    // 生成随机字符
    public static String getRandomString(int length) {
        String str = "abcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new Random();
        StringBuilder sb = new StringBuilder();

        for(int i = 0; i < length; ++i) {
            int number = random.nextInt(36);
            sb.append(str.charAt(number));
        }
        return sb.toString();
    }

}