package fun.fireline.tools;

// http 请求对象，取自 shack2 的Java反序列化漏洞利用工具V1.7

import fun.fireline.core.ExploitInterface;
import fun.fireline.exp.jenkins.*;

public class Tools {
    public Tools() {
    }


    public static String urlParse(String url) {
        if (!url.contains("http")) {
            url = "http://" + url;
        }

        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }

        return url;
    }


    // 根据选择对应的漏洞检测
    public static ExploitInterface getExploit(String vulName) {
        ExploitInterface ei = null;

        // Jenkins相关漏洞
        if(vulName.contains("CVE-2015-8103")){
            ei = new CVE_2015_8103();
        } else if(vulName.contains("CVE-2016-0792")){
            ei = new CVE_2016_0792();
        }else if(vulName.contains("CVE-2017-1000353")){
            ei = new CVE_2017_1000353();
        } else if(vulName.contains("CVE-2018-1000600")){
            ei = new CVE_2018_1000600();
        }else if(vulName.contains("CVE-2018-1000861")) {
            ei = new CVE_2018_1000861();
        } else if(vulName.contains("CVE-2018-1999002")){
            ei = new CVE_2018_1999002();
        }else if(vulName.contains("CVE-2019-1003000")){
            ei = new CVE_2019_1003000();
        }else if(vulName.contains("CVE-2019-1003005")){
            ei = new CVE_2019_1003005();
        }else if(vulName.contains("CVE-2024-23897")) {
            ei = new CVE_2024_23897();
        }

        return (ExploitInterface) ei;
    }

    public static boolean compare1(String version){
        int count = version.split("\\.").length - 1;
        //Jenkins 普通版本和LTS版本
        if(count==1){
            return true;
        }else{
            return false;
        }
    }

    public static int compare2(String version1, String version2) {
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        int length = Math.max(v1.length, v2.length);
        for (int i = 0; i < length; i++) {
            double num1 = (i < v1.length) ? Double.parseDouble(v1[i]) : 0;
            double num2 = (i < v2.length) ? Double.parseDouble(v2[i]) : 0;
            if (num1 < num2) {
                return -1;
            } else if (num1 > num2) {
                return 1;
            }
        }
        return 0;
    }

    public static boolean compareVersion(String version1,String version2,String version3){
        if(compare1(version1)){
            if(compare2(version1,version2)<=0){
                return true;
            }
        }else {
            if(compare2(version1,version3)<=0){
                return true;
            }
        }
        return false;
    }

}