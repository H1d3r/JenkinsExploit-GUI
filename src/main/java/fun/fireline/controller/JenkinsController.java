package fun.fireline.controller;

import fun.fireline.core.Constants;
import fun.fireline.core.ExploitInterface;
import fun.fireline.core.VulCheckTask;
import fun.fireline.tools.Tools;
import javafx.fxml.FXML;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;


// JavaFX图形化界面的控制类
public class JenkinsController extends MainController{
    @FXML
    private ChoiceBox<String> choice_cve;
    @FXML
    private ChoiceBox<String> encoding;
    @FXML
    private ChoiceBox<String> platform;
    @FXML
    private TextArea basic_info;
    @FXML
    private TextArea cmd_info;
    @FXML
    private TextField cmd;
    @FXML
    private TextField url;

    private ExploitInterface ei;

    public static String BASICINFO = Constants.SECURITYSTATEMENT +

            "支持检测: \r\n" +
            "\tCVE-2015-8103/CVE-2016-0788 Jenkins 反序列化远程代码执行 https://github.com/Medicean/VulApps/tree/master/j/jenkins/1\r\n"+
            "\tCVE-2016-0792 Jenkins XStream反序列化远程代码执行 https://github.com/jpiechowka/jenkins-cve-2016-0792\r\n"+
            "\tCVE-2017-1000353 Jenkins-CI 远程代码执行漏洞 https://github.com/vulhub/CVE-2017-1000353\r\n"+
            "\tCVE-2018-1000600 Jenkins GitHub SSRF+信息泄露\r\n"+
            "\tCVE-2018-1000861 Jenkins 绕过Groovy沙盒未授权命令执行漏洞 https://github.com/orangetw/awesome-jenkins-rce-2019\r\n"+
            "\tCVE-2018-1999002 Jenkins 任意文件读取 https://mp.weixin.qq.com/s/MOKeN1qEBonS8bOLw6LH_w\r\n"+
            "\tCVE-2019-1003000 Jenkins 远程代码执行 https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc\r\n"+
            "\tCVE-2019-1003005/CVE-2019-1003029 远程代码执行(Script Security Plugin沙箱绕过) https://github.com/orangetw/awesome-jenkins-rce-2019\r\n"+
            "\tCVE-2024-23897 Jenkins CLI 接口任意文件读取漏洞 https://github.com/vulhub/vulhub/blob/master/jenkins/CVE-2024-23897\r\n" +
            "\t未完待续:\r\n"+
            "\tCVE-2016-9299 Jenkins ldap反序列化远程代码执行\r\n"+
            "\t再添加一个dnslog的api设置,使得能够自动化检测无回显的命令执行\r\n"+
            "\t添加macOS的外部payload\r\n"+
            "\t添加批量检测功能\r\n"+
            "\t继续尝试把外置的payload接入到java代码中\r\n\r\n"+

            Constants.UPDATEINFO;

    public static String[] Jenkins = {
            "all",
            "CVE-2015-8103/CVE-2016-0788 Jenkins 反序列化远程代码执行",
            "CVE-2016-0792 Jenkins XStream反序列化远程代码执行",
            "CVE-2017-1000353 Jenkins-CI 远程代码执行漏洞",
            "CVE-2018-1000600 Jenkins GitHub SSRF+信息泄露",
            "CVE-2018-1000861 Jenkins 绕过Groovy沙盒未授权命令执行漏洞",
            "CVE-2018-1999002 Jenkins 任意文件读取",
            "CVE-2019-1003000 Jenkins 远程代码执行",
            "CVE-2019-1003005/CVE-2019-1003029 远程代码执行(Script Security Plugin沙箱绕过)",
            "CVE-2024-23897 Jenkins CLI 接口任意文件读取漏洞",
    };



    // 界面显示  一些默认的基本信息，漏洞列表、编码选项、线程、shell、页脚
    public void defaultInformation() {
        this.choice_cve.setValue(Jenkins[0]);
        for (String cve : Jenkins) {
            this.choice_cve.getItems().add(cve);
        }
        this.encoding.setValue(Constants.ENCODING[0]);

        for (String coding : Constants.ENCODING) {
            this.encoding.getItems().add(coding);
        }

        // 命令执行
        this.cmd_info.setText(" ");
        this.cmd_info.setWrapText(true);

        this.platform.setValue("Linux");
        this.platform.getItems().add("Linux");
        this.platform.getItems().add("Windows");

    }

    // 基本信息
    public void basic() {
        // 切换界面保留原来的记录
        // 基本信息的历史记录
        if(history.containsKey("Jenkins_url")) {
            this.url.setText((String) history.get("Jenkins_url"));
        }
        if(history.containsKey("Jenkins_vulName")) {
            this.choice_cve.setValue((String) history.get("Jenkins_vulName"));
        }
        if(history.containsKey("Jenkins_ei")) {
            this.ei = (ExploitInterface) history.get("Jenkins_ei");
        }
        if(history.containsKey("Jenkins_basic_info")) {
            this.basic_info.setText((String) history.get("Jenkins_basic_info"));
        } else {
            this.basic_info.setText(BASICINFO);
        }
        this.basic_info.setWrapText(true);

        // 命令执行的历史记录
        if(history.containsKey("Jenkins_cmd")) {
            this.cmd.setText((String) history.get("Jenkins_cmd"));
        }
        if(history.containsKey("Jenkins_encoding")) {
            this.encoding.setValue((String) history.get("Jenkins_encoding"));
        }
        if(history.containsKey("Jenkins_cmd_info")) {
            this.cmd_info.setText((String) history.get("Jenkins_cmd_info"));
        }

    }

    // 点击检测，获取url 和 要检测的漏洞
    @FXML
    public void check() {
        String url = Tools.urlParse(this.url.getText().trim());
        history.put("Jenkins_url", this.url.getText());
        String vulName = this.choice_cve.getValue().toString().trim();
        history.put("Jenkins_vulName", this.choice_cve.getValue());

        try {
            if (vulName.equals("all")) {
                this.basic_info.setText("");
                for (String vul : this.choice_cve.getItems()) {
                    if (!vul.equals("all")) {
                        //等待Jenkins_Info获取完
                        Thread.sleep(100);
                        VulCheckTask vulCheckTask = new VulCheckTask(this.url.getText(), vul);
                        vulCheckTask.messageProperty().addListener((observable, oldValue, newValue) -> {
                            this.basic_info.appendText("\t" + newValue + "\r\n\r\n");
                            if(newValue.contains("[+]")) {
                                this.choice_cve.setValue(vul);
                                this.ei = Tools.getExploit(vul);
                                this.ei.checkVul(url);
                            }
                        });
                        (new Thread(vulCheckTask)).start();
                    }
                }
            } else {
                this.ei = Tools.getExploit(vulName);
                String result = this.ei.checkVul(url);

                this.basic_info.setText("\r\n\t" + result + "\r\n\r\n\t");

            }

        } catch (Exception e) {
            this.basic_info.setText("\r\n\t检测异常 \r\n\t\t\t" + e.toString());
        }

        history.put("Jenkins_ei", this.ei);

        history.put("Jenkins_basic_info", this.basic_info.getText());

    }

    // 命令执行
    @FXML
    public void get_execute_cmd() {
        String cmd = this.cmd.getText();
        String encoding = this.encoding.getValue().toString().trim();

        history.put("Jenkins_cmd", this.cmd.getText());
        history.put("Jenkins_encoding", this.encoding.getValue());

        if(cmd.length() == 0) {
            cmd = "whoami";
        }

        try {
            if(this.ei.isVul()) {
                String result = this.ei.exeCmd(cmd, encoding);
                this.cmd_info.setText(result);

            } else {
                this.cmd_info.setText("请先进行漏洞检测，确认漏洞存在");
            }

        } catch (Exception var4) {
            this.cmd_info.setText("请先进行漏洞检测，确认漏洞存在\r\n");
            this.cmd_info.appendText("error: " + var4.toString());
        }
        history.put("Jenkins_cmd_info", this.cmd_info.getText());
    }

    // 加载
    public void initialize() {
        try {
            this.basic();
            this.defaultInformation();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


}